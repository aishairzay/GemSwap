{"transactions":{"ClaimGem":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport Gem from 0xGem\nimport GemGames from 0xGemGames\n\npub fun initializeCollection(account: AuthAccount) {\n    if account.borrow<&Gem.Collection>(from: Gem.CollectionStoragePath) == nil {\n        let collection <- Gem.createEmptyCollection()\n        \n        account.save(<-collection, to: Gem.CollectionStoragePath)\n\n        account.link<&Gem.Collection{NonFungibleToken.CollectionPublic, Gem.GemCollectionPublic, MetadataViews.ResolverCollection}>(\n            Gem.CollectionPublicPath, \n            target: Gem.CollectionStoragePath\n        )\n    }\n\n}\n\ntransaction(claimAddress: Address, setId: UInt64) {\n    let claimerAddress: Address\n\n    prepare(signer: AuthAccount) {\n        self.claimerAddress = signer.address\n        initializeCollection(account: signer)\n    }\n\n    execute {\n        let gameRef = getAccount(claimAddress).getCapability(GemGames.GemGameManagerPublicPath)!.borrow<&GemGames.GemGameManager{GemGames.IGameManagerPublic}>()!.borrowGame(setId: setId)!\n\n        gameRef.claim(address: self.claimerAddress)\n    }\n}","CreateGemGame":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport Gem from 0xGem\nimport GemGames from 0xGemGames\n\npub fun getOrCreateGameCollection(\n    account: AuthAccount,\n    setId: UInt64\n): Capability<&Gem.Collection> {\n     let collectionCap = account.getCapability<&Gem.Collection>(GemGames.getGameCollectionPrivatePath(setId: setId))\n\n     if collectionCap.check() {\n        return collectionCap\n     }\n\n     let collection <- Gem.createEmptyCollection()\n     account.save(<-collection, to: GemGames.getGameCollectionStoragePath(setId: setId))\n     account.link<&Gem.Collection>(GemGames.getGameCollectionPrivatePath(setId: setId), target: GemGames.getGameCollectionStoragePath(setId: setId))\n     account.link<&Gem.Collection{NonFungibleToken.CollectionPublic, Gem.GemCollectionPublic, MetadataViews.ResolverCollection}>(GemGames.getGameCollectionPublicPath(setId: setId), target: GemGames.getGameCollectionStoragePath(setId: setId))\n\n     return collectionCap\n\n}\n\ntransaction(name: String, prizes: String) {\n    let gemGameManagerRef: &GemGames.GemGameManager\n\n    prepare(signer: AuthAccount) {\n        self.gemGameManagerRef = signer.borrow<&GemGames.GemGameManager>(from: GemGames.GemGameManagerStoragePath)\n            ?? panic(\"Could not borrow reference to the GemGameManager\")\n\n        let setId = self.gemGameManagerRef.createSet()\n\n        self.gemGameManagerRef.createGame(setId: setId, name: name, prizes: prizes, setCollection: getOrCreateGameCollection(account: signer, setId: setId))\n    }\n    \n    execute {}\n}","CreateSecretMessageVault":"import VaultService from 0xVaultService\n\ntransaction(description: String, thumbnail: String, passwordSalt: String, hashControl: String, hashAlgorithm: String, encryptedMessage: String?, encryptionAlgorithm: String?, derivedPublicKey: String?) {\n  let vaultCollection: &VaultService.VaultCollection\n\n  prepare(signer: AuthAccount) {\n    var vaultCollectionCap = signer.borrow<&VaultService.VaultCollection>(from: /storage/VaultCollection)\n    if (vaultCollectionCap == nil) {\n      let vaultCollection <- VaultService.createVaultCollection()\n      signer.save(<-vaultCollection, to: /storage/VaultCollection)\n      vaultCollectionCap = signer.borrow<&VaultService.VaultCollection>(from: /storage/VaultCollection)\n      self.vaultCollection = vaultCollectionCap!\n    } else {\n      self.vaultCollection = vaultCollectionCap!\n    }\n    signer.link<&{VaultService.VaultCollectionPublic}>(/public/VaultCollection, target: /storage/VaultCollection)\n  }\n\n  execute {\n    let vault <- VaultService.createVault(description: description, thumbnail: thumbnail, passwordSalt: passwordSalt, hashControl: hashControl, hashAlgorithm: hashAlgorithm, encryptedMessage: encryptedMessage, encryptionAlgorithm: encryptionAlgorithm, derivedPublicKey: derivedPublicKey, action: nil)\n    self.vaultCollection.deposit(vault: <-vault)\n  }\n}\n","MintGems":"import GemGames from 0xGemGames\n\n\ntransaction(setId: UInt64, colors: [String]) {\n    let gemGameManagerRef: &GemGames.GemGameManager\n\n    prepare(signer: AuthAccount) {\n        self.gemGameManagerRef = signer.borrow<&GemGames.GemGameManager>(from: GemGames.GemGameManagerStoragePath)\n            ?? panic(\"Could not borrow reference to the GemGameManager\")\n        \n    }\n\n    \n    execute {\n        for color in colors {\n            self.gemGameManagerRef.mintNFT(setId: setId, color: color)\n        }\n\n    }\n}","SetupGemGameManager":"import GemGames from 0xGemGames\n\ntransaction() {\n    prepare(signer: AuthAccount) {\n        if signer.borrow<&GemGames.GemGameManager>(from: GemGames.GemGameManagerStoragePath) != nil {\n            return\n        }\n        signer.save(<- GemGames.createGemGameManager(), to: GemGames.GemGameManagerStoragePath)\n        signer.link<&GemGames.GemGameManager>(GemGames.GemGameManagerPrivatePath, target: GemGames.GemGameManagerStoragePath)\n        signer.link<&GemGames.GemGameManager{GemGames.IGameManagerPublic}>(GemGames.GemGameManagerPublicPath, target: GemGames.GemGameManagerStoragePath)\n    }\n}","SwapGems":"import NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport Gem from 0xGem\nimport GemGames from 0xGemGames\n\npub fun initializeCollection(account: AuthAccount) {\n    if account.borrow<&Gem.Collection>(from: Gem.CollectionStoragePath) == nil {\n        let collection <- Gem.createEmptyCollection()\n        \n        account.save(<-collection, to: Gem.CollectionStoragePath)\n\n        account.link<&Gem.Collection{NonFungibleToken.CollectionPublic, Gem.GemCollectionPublic, MetadataViews.ResolverCollection}>(\n            Gem.CollectionPublicPath, \n            target: Gem.CollectionStoragePath\n        )\n    }\n}\n\ntransaction(offeredIds: [UInt64], requestedIds: [UInt64]) {\n\n    let offerer: &Gem.Collection\n    let requester: &Gem.Collection\n\n    prepare(offerer: AuthAccount, requester: AuthAccount) {\n        initializeCollection(account: offerer)\n        initializeCollection(account: requester)\n        self.offerer = offerer.borrow<&Gem.Collection>(from: Gem.CollectionStoragePath)!\n        self.requester = requester.borrow<&Gem.Collection>(from: Gem.CollectionStoragePath)!\n    }\n\n    execute {\n        let offererIds = self.offerer.getIDs()\n        let requesterIds = self.requester.getIDs()\n\n        for id in offeredIds {\n            let withdrawn = self.offerer.withdraw(withdrawID: id)\n            if !withdrawn {\n                panic(\"Offerer does not own token with ID: \\(id)\")\n            }\n            requester.deposit(token: <-withdrawn)\n        }\n\n        for id in requestedIds {\n            let withdrawn = self.requester.withdraw(withdrawID: id)\n            if !withdrawn {\n                panic(\"Requester does not own token with ID: \\(id)\")\n            }\n            offerer.deposit(token: <-withdrawn)\n        }\n        \n    }\n}"},"scripts":{"GetGem":"import MetadataViews from 0xMetadataViews\nimport NonFungibleToken from 0xNonFungibleToken\nimport Gem from 0xGem\n\n\npub struct NFT {\n    pub let id: UInt64\n    pub let setId: UInt64\n    pub let display: MetadataViews.Display\n    \n    init(\n        id: UInt64,\n        setId: UInt64,\n        display: MetadataViews.Display,\n    ) {\n        self.id = id\n        self.setId = setId\n        self.display = display\n    }\n}\n\n\npub fun main(address: Address, id: UInt64): NFT? {\n    if let col = getAccount(address).getCapability<&Gem.Collection{NonFungibleToken.CollectionPublic, Gem.GemCollectionPublic}>(Gem.CollectionPublicPath).borrow() {\n        if let nft = col.borrowGem(id: id) {\n\n            let display = nft.resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display\n\n            return NFT(\n                id: id,\n                setId: nft.setId,\n                display: display\n            )\n        }\n    }\n\n    return nil\n}","GetGemGameForSetId":"import GemGames from 0xGemGames\nimport Gem from 0xGem\n\npub fun main(setId: UInt64): GemGames.GemGameInfo? {\n    return GemGames.getGameForSetId(setId: setId)\n}","GetGemGameSetIds":"import NonFungibleToken from 0xNonFungibleToken\nimport GemGames from 0xGemGames\n\npub fun main (): [UInt64] {\n    return GemGames.getGameSetIds()\n}","GetGemIds":"import NonFungibleToken from 0xNonFungibleToken\nimport Gem from 0xGem\n\npub fun main (address: Address): [UInt64] {\n     if let col = getAccount(address).getCapability<&Gem.Collection{NonFungibleToken.CollectionPublic}>(Gem.CollectionPublicPath).borrow() {\n        return col.getIDs()\n    }\n\n    return []\n}","GetGemsForAccount":"import NonFungibleToken from 0xNonFungibleToken\nimport Gem from 0xGem\nimport MetadataViews from 0xMetadataViews\n\n\npub struct NFT {\n    pub let id: UInt64\n    pub let setId: UInt64\n    pub let display: MetadataViews.Display\n    \n    init(\n        id: UInt64,\n        setId: UInt64,\n        display: MetadataViews.Display,\n    ) {\n        self.id = id\n        self.setId = setId\n        self.display = display\n    }\n}\n\npub fun main (address: Address): [NFT] {\n    let res: [NFT] = []\n    if let col = getAccount(address).getCapability<&Gem.Collection{NonFungibleToken.CollectionPublic, Gem.GemCollectionPublic}>(Gem.CollectionPublicPath).borrow() {\n      for id in col.getIDs() {\n        if let nft = col.borrowGem(id: id) {\n          let display = nft.resolveView(Type<MetadataViews.Display>())! as! MetadataViews.Display\n          res.append(\n            NFT(\n              id: id,\n              setId: nft.setId,\n              display: display\n            )\n          )\n        }\n      }\n    }\n    return res\n}","GetVaultByVaultID":"import VaultService from 0xVaultService\n\npub fun main(vaultID: UInt64):AnyStruct {\n  let address = VaultService.vaultAddresses[vaultID] ?? panic(\"No address found\")\n  let vaultCollection = getAccount(address).getCapability<&{VaultService.VaultCollectionPublic}>(/public/VaultCollection).borrow()\n    ?? panic(\"Could not borrow capability from public collection\")\n  let vault = vaultCollection.borrowVault(uuid: vaultID)\n  return vault\n}\n","GetVaults":"import VaultService from 0xVaultService\n\npub fun main(address: Address):[AnyStruct] {\n  let vaultCollection = getAccount(address).getCapability<&{VaultService.VaultCollectionPublic}>(/public/VaultCollection).borrow()\n    ?? panic(\"Could not borrow capability from public collection\")\n  let ids = vaultCollection.getIDs()\n  var vaults: [AnyStruct] = []\n  for id in ids {\n    let vault = vaultCollection.borrowVault(uuid: id)\n    vaults.append(vault)\n  }\n  return vaults\n}\n"},"vars":{"emulator":{"0xFungibleToken":"0xee82856bf20e2aa6","0xMetadataViews":"0xf3fcd2c1a78f5eee","0xViewResolver":null,"0xNonFungibleToken":"0xf3fcd2c1a78f5eee","0xGem":null,"0xGemGames":null},"testnet":{"0xFungibleToken":"0x9a0766d93b6608b7","0xMetadataViews":"0x631e88ae7f1d7c20","0xViewResolver":"0x631e88ae7f1d7c20","0xNonFungibleToken":"0x631e88ae7f1d7c20","0xGem":"0x61e8d5e776442710","0xGemGames":"0x61e8d5e776442710"},"mainnet":{"0xFungibleToken":"0xf233dcee88fe0abe","0xMetadataViews":"0x1d7e57aa55817448","0xViewResolver":"0x1d7e57aa55817448","0xNonFungibleToken":"0x1d7e57aa55817448","0xGem":null,"0xGemGames":null}}}